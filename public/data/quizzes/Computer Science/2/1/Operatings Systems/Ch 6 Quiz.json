{
  "meta": {
    "title": "Ch 6 Quiz",
    "id": "N263XGBP",
    "createdAt": "2026-03-01 - 20:37",
    "path": "quizzes/Computer Science/2/1/Operatings Systems/Ch 6 Quiz.json"
  },
  "stats": {
    "questionCount": 37,
    "questionTypes": [
      "MCQ",
      "True/False"
    ]
  },
  "questions": [
    {
      "q": "What is the primary goal of CPU Scheduling?",
      "explanation": "The goal is to keep the CPU as busy as possible to get the most work done.",
      "options": [
        "Reduce memory usage",
        "Maximize CPU utilization",
        "Reduce temporary file size",
        "Increase I/O speed"
      ],
      "correct": 1
    },
    {
      "q": "Process execution consists of a cycle of:",
      "explanation": "Processes alternate between performing calculations (CPU burst) and waiting for input/output (I/O burst).",
      "options": [
        "CPU burst only",
        "I/O burst only",
        "CPU burst followed by I/O burst",
        "I/O burst followed by CPU burst"
      ],
      "correct": 2
    },
    {
      "q": "The short-term scheduler selects processes from:",
      "explanation": "The ready queue holds all processes that are prepared and waiting to execute on the CPU.",
      "options": [
        "Job queue",
        "Ready queue",
        "Device queue",
        "Termination queue"
      ],
      "correct": 1
    },
    {
      "q": "When is scheduling nonpreemptive?",
      "explanation": "Nonpreemptive means the process keeps the CPU until it either terminates or switches to a waiting state (like for I/O).",
      "options": [
        "Switch from running to ready",
        "Switch from waiting to ready",
        "Switch from running to waiting",
        "When a new process arrives"
      ],
      "correct": 2
    },
    {
      "q": "The Dispatcher is responsible for:",
      "explanation": "The dispatcher is the module that actually gives control of the CPU to the process selected by the short-term scheduler.",
      "options": [
        "Loading programs into memory",
        "Terminating processes",
        "Giving CPU control to the selected process and switching context",
        "Allocating memory to processes"
      ],
      "correct": 2
    },
    {
      "q": "Dispatch latency refers to:",
      "explanation": "This is the overhead time taken by the dispatcher to stop one process and start the next one.",
      "options": [
        "Time to load a program from disk",
        "Time to send data over the network",
        "Time to stop one process and start another",
        "Time a process waits in the queue"
      ],
      "correct": 2
    },
    {
      "q": "Which criterion measures the number of completed processes per time unit?",
      "explanation": "Throughput is the rate at which processes are finished.",
      "options": [
        "CPU utilization",
        "Throughput",
        "Turnaround time",
        "Waiting time"
      ],
      "correct": 1
    },
    {
      "q": "Turnaround time is defined as:",
      "explanation": "It measures the total time a process takes from start to finish.",
      "options": [
        "Time spent waiting in the ready queue",
        "Time from submission until completion",
        "Time from request submission until first response",
        "Time the process spends executing"
      ],
      "correct": 1
    },
    {
      "q": "In FCFS scheduling, the Convoy Effect occurs when:",
      "explanation": "Like a slow truck leading a line of fast cars, short processes get stuck behind one very long process.",
      "options": [
        "Short processes arrive first",
        "A long process arrives first and short ones wait behind it",
        "Priorities are equal",
        "The quantum is too small"
      ],
      "correct": 1
    },
    {
      "q": "SJF (Shortest Job First) scheduling provides:",
      "explanation": "SJF is mathematically optimal for minimizing the average time processes spend waiting.",
      "options": [
        "Minimum average waiting time",
        "Maximum memory usage",
        "Minimum CPU usage",
        "Maximum I/O speed"
      ],
      "correct": 0
    },
    {
      "q": "The main difficulty in implementing SJF is:",
      "explanation": "It is hard to predict exactly how long the next CPU burst will be before it happens.",
      "options": [
        "High computational complexity",
        "Not knowing the length of the next CPU burst",
        "It requires large memory",
        "It doesn't work in multiprocessor systems"
      ],
      "correct": 1
    },
    {
      "q": "The preemptive version of SJF is called:",
      "explanation": "SRTF will interrupt the current process if a new process arrives with a shorter remaining time.",
      "options": [
        "Priority Scheduling",
        "Round Robin",
        "SRTF (Shortest Remaining Time First)",
        "Multilevel Queue"
      ],
      "correct": 2
    },
    {
      "q": "In Priority Scheduling, starvation is solved by:",
      "explanation": "Aging gradually increases the priority of processes that wait for a long time.",
      "options": [
        "Increasing memory size",
        "Aging",
        "Reducing the number of processes",
        "Using a smaller quantum"
      ],
      "correct": 1
    },
    {
      "q": "When the time quantum is very large in Round Robin, it behaves like:",
      "explanation": "If the quantum is longer than the process bursts, it simply runs processes in the order they arrived (First-Come, First-Served).",
      "options": [
        "SJF",
        "Priority Scheduling",
        "FCFS",
        "Multilevel Feedback Queue"
      ],
      "correct": 2
    },
    {
      "q": "Round Robin performance depends heavily on:",
      "explanation": "If the quantum is too small, context switching overhead is too high; if too large, it becomes FCFS.",
      "options": [
        "Number of processes in the system",
        "Size of the time quantum",
        "Hard disk speed",
        "RAM capacity"
      ],
      "correct": 1
    },
    {
      "q": "In Multilevel Queue scheduling, the foreground (interactive) queue typically uses:",
      "explanation": "Round Robin is better for interactive users because it ensures a quick response time.",
      "options": [
        "FCFS",
        "SJF",
        "Round Robin",
        "Priority"
      ],
      "correct": 2
    },
    {
      "q": "Multilevel Feedback Queue allows processes to:",
      "explanation": "Processes can move up or down between queues based on their behavior (like CPU-bound vs I/O-bound).",
      "options": [
        "Skip the ready queue",
        "Move between different queues",
        "Execute themselves automatically",
        "Change their own priority"
      ],
      "correct": 1
    },
    {
      "q": "User-level thread scheduling is known as:",
      "explanation": "PCS means threads in the same process compete with each other for available 'lightweight process' resources.",
      "options": [
        "System-Contention Scope (SCS)",
        "Process-Contention Scope (PCS)",
        "Global Scheduling",
        "Local Scheduling"
      ],
      "correct": 1
    },
    {
      "q": "PTHREAD_SCOPE_SYSTEM in POSIX corresponds to:",
      "explanation": "SCS means the thread competes against all other threads in the entire system.",
      "options": [
        "PCS",
        "SCS",
        "User-level thread scheduling only",
        "No scheduling allowed"
      ],
      "correct": 1
    },
    {
      "q": "In Symmetric Multiprocessing (SMP), each processor may have its own:",
      "explanation": "In many SMP systems, each CPU has its own private queue of processes ready to run.",
      "options": [
        "Device queue",
        "Ready queue",
        "Termination queue",
        "Network access queue"
      ],
      "correct": 1
    },
    {
      "q": "Processor affinity means a process prefers to execute on:",
      "explanation": "Running on the same CPU is more efficient because the CPU's cache might still contain the process's data.",
      "options": [
        "Any available processor",
        "The same processor it last ran on",
        "The fastest processor in the system",
        "The least loaded processor"
      ],
      "correct": 1
    },
    {
      "q": "Load balancing in SMP can be achieved through:",
      "explanation": "Overloaded CPUs can push tasks away, and idle CPUs can pull tasks from busy ones.",
      "options": [
        "Push migration only",
        "Pull migration only",
        "Both push and pull migration",
        "Disabling some processors"
      ],
      "correct": 2
    },
    {
      "q": "CPU scheduling is only necessary in single-processor systems.",
      "explanation": "Scheduling is needed in both single and multiprocessor systems to manage how tasks use the available CPU cores.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    },
    {
      "q": "In the CPU-I/O burst cycle, processes alternate between CPU execution and I/O wait states.",
      "explanation": "A process spends its life moving between doing math/logic (CPU) and waiting for data (I/O).",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "The short-term scheduler selects processes from the job queue to load into memory.",
      "explanation": "The short-term scheduler selects from the 'Ready Queue'; loading into memory is typically the job of a long-term scheduler.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    },
    {
      "q": "Scheduling decisions are nonpreemptive when a process terminates.",
      "explanation": "When a process finishes, it leaves the CPU voluntarily, making it a nonpreemptive scheduling point.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "The dispatcher is responsible for selecting which process runs next on the CPU.",
      "explanation": "The scheduler *selects* the process, while the dispatcher *gives control* of the CPU to that process.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    },
    {
      "q": "Turnaround time includes the time a process spends waiting in the ready queue.",
      "explanation": "Turnaround time is the total time from submission to completion, which includes waiting and execution.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "FCFS scheduling always provides the minimum average waiting time.",
      "explanation": "First-Come, First-Served can be very slow (Convoy Effect); SJF is the one that minimizes waiting time.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    },
    {
      "q": "SJF scheduling is optimal in terms of minimizing average waiting time.",
      "explanation": "Mathematically, Shortest Job First is the best way to keep average wait times as low as possible.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "In Priority Scheduling, lower priority numbers always indicate higher priority.",
      "explanation": "While it can vary by system, in general computing theory, 0 or 1 is usually the highest priority.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "Round Robin scheduling is inherently preemptive.",
      "explanation": "It uses a timer (quantum) to force a process off the CPU so others can take a turn.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "In Round Robin, if the time quantum is too small, it can lead to high context switch overhead.",
      "explanation": "If the CPU switches tasks too often, it spends more time 'switching' than actually doing work.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "Multilevel Queue scheduling allows processes to move between different queues.",
      "explanation": "In a standard Multilevel Queue, processes stay in their assigned queue. They only move in a 'Multilevel Feedback Queue'.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    },
    {
      "q": "The Completely Fair Scheduler (CFS) in Linux uses a red-black tree to select the next task to run.",
      "explanation": "The red-black tree helps Linux quickly find the task that has had the least amount of CPU time (vruntime).",
      "options": [
        "True",
        "False"
      ],
      "correct": 0
    },
    {
      "q": "Processor affinity means that a process can only run on one specific processor in an SMP system.",
      "explanation": "It usually means a *preference* (soft affinity) to stay on the same CPU, not a strict requirement.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    },
    {
      "q": "Load balancing in SMP systems can only be done through push migration.",
      "explanation": "It uses both 'push' (moving tasks from busy CPUs) and 'pull' (idle CPUs taking tasks from busy ones).",
      "options": [
        "True",
        "False"
      ],
      "correct": 1
    }
  ]
}