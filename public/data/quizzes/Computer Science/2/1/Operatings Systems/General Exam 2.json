{
  "questions": [
    {
      "q": "Which program is the one always running at all times on the computer, serving as the core of the operating system?",
      "options": [
        "The Bootstrap Program",
        "The Kernel",
        "The Shell",
        " The GUI"
      ],
      "correct": 1,
      "explanation": "The kernel is the one program running at all times on the computer. All other components are considered system or application programs[cite: 374]."
    },
    {
      "q": "The operating system operates in dual-mode (User Mode and Kernel Mode) to protect the system from errant user programs.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0,
      "explanation": "The distinction between kernel mode and user mode provides a rudimentary form of protection, ensuring privileged instructions and hardware access are restricted to the kernel[cite: 377]."
    },
    {
      "q": "Which mechanism allows user-level processes to request services from the operating system?",
      "options": [
        "Interrupts",
        "Context Switching",
        "System Calls",
        "Threading"
      ],
      "correct": 2,
      "explanation": "System calls provide the interface for user-level processes to request services from the operating system[cite: 175]."
    },
    {
      "q": "In the context of process creation in UNIX, what does the `fork()` system call do?",
      "options": [
        "It loads a new binary executable into memory.",
        "It terminates the current process.",
        "It creates a new process by cloning the currently executing process.",
        "It switches the CPU to kernel mode."
      ],
      "correct": 2,
      "explanation": "The fork system call clones the currently executing process to create a new one[cite: 213]."
    },
    {
      "q": "Define 'Context Switch'.",
      "options": [
        "Context switching is the process of saving the state of the current process (or thread) and restoring the state of a new process (or thread) so that execution can be switched."
      ],
      "correct": 0,
      "explanation": "Context switching involves saving the CPU registers of the thread/process being switched out and restoring the registers of the new one[cite: 151]."
    },
    {
      "q": "Which of the following data structures is used by the OS to store all information specific to a process (e.g., Program Counter, CPU registers)?",
      "options": [
        "Process Control Block (PCB)",
        "File Control Block",
        "Thread Library",
        "Bootstrap Loader"
      ],
      "correct": 0,
      "explanation": "The Process Control Block (PCB) is a data structure allocated to hold specific information for a process, including the memory map and register set[cite: 158]."
    },
    {
      "q": "Threads within the same process share which of the following resources?",
      "options": [
        "Stack",
        "Registers",
        "Program Counter",
        "Address space and open files"
      ],
      "correct": 3,
      "explanation": "Threads share the address space (code and data) and resources like open files, but they maintain their own registers and stack[cite: 161]."
    },
    {
      "q": "User-level threads are generally slower to create and manage than kernel-level threads.",
      "options": [
        "True",
        "False"
      ],
      "correct": 1,
      "explanation": "False.  Kernel threads are generally more expensive to maintain than user threads because they must be represented with a kernel data structure[cite: 148]."
    },
    {
      "q": "According to Amdahl's Law, what limits the speedup gain from adding more cores to a computing system?",
      "options": [
        "The clock speed of the CPU.",
        "The amount of serial (non-parallel) components in the application.",
        "The size of the RAM.",
        "The number of I/O devices."
      ],
      "correct": 1,
      "explanation": "Amdahl's law illustrates that performance gains are limited by the serial portion of an application, even as the number of processing cores increases[cite: 137]."
    },
    {
      "q": "Explain the 'Convoy Effect' in CPU Scheduling.",
      "options": [
        "The Convoy Effect occurs in FCFS scheduling when a long CPU-bound process holds the CPU, causing many shorter I/O-bound processes to wait behind it, lowering overall device utilization."
      ],
      "correct": 0,
      "explanation": "The convoy effect is described as short processes waiting behind a long process, typically seen in First-Come, First-Served (FCFS) scheduling[cite: 113]."
    },
    {
      "q": "Which scheduling algorithm is proven to be optimal for minimizing average waiting time?",
      "options": [
        "First-Come, First-Served (FCFS)",
        "Round Robin (RR)",
        "Shortest-Job-First (SJF)",
        "Priority Scheduling"
      ],
      "correct": 2,
      "explanation": "SJF is optimal because it gives the minimum average waiting time for a given set of processes[cite: 114]."
    },
    {
      "q": "In a Round Robin scheduling algorithm, what happens if the time quantum (q) is extremely large?",
      "options": [
        "The system becomes responsive.",
        "The algorithm behaves like First-Come, First-Served (FCFS).",
        "Context switching overhead becomes too high.",
        "Starvation of processes occurs."
      ],
      "correct": 1,
      "explanation": "If the time quantum (q) is large, the Round Robin algorithm effectively becomes a First-Come, First-Served (FIFO/FCFS) algorithm[cite: 128]."
    },
    {
      "q": "What is 'Starvation' in the context of Priority Scheduling?",
      "options": [
        "When a process uses too much memory.",
        "When the CPU is idle due to lack of processes.",
        "When low priority processes may never execute because high priority processes keep arriving.",
        "When a process terminates before finishing its task."
      ],
      "correct": 2,
      "explanation": "Starvation is the problem where low priority processes may never execute[cite: 122]."
    },
    {
      "q": "What is the standard solution to the problem of Starvation?",
      "options": [
        "Aging"
      ],
      "correct": 0,
      "explanation": "Aging is the solution to starvation; it involves gradually increasing the priority of a process as it waits in the system[cite: 122]."
    },
    {
      "q": "In Preemptive Shortest-Job-First (Shortest-Remaining-Time-First), a currently running process will be interrupted if a new process arrives with a shorter CPU burst than what remains of the current process.",
      "options": [
        "True",
        "False"
      ],
      "correct": 0,
      "explanation": "Preemptive SJF (Shortest-Remaining-Time-First) will preempt the current process if a newly arriving process has a shorter predicted CPU burst[cite: 116]."
    },
    {
      "q": "What are the three main activities of Memory Management in an Operating System?",
      "options": [
        "1. Keeping track of memory usage (who is using what). 2. Deciding which processes to load when space is available. 3. Allocating and deallocating memory space."
      ],
      "correct": 0,
      "explanation": "The three activities are tracking memory usage, deciding loading order, and allocating/deallocating space[cite: 189]."
    },
    {
      "q": "Which CPU scheduling criteria refers to the number of processes that complete their execution per time unit?",
      "options": [
        "CPU Utilization",
        "Throughput",
        "Turnaround Time",
        "Response Time"
      ],
      "correct": 1,
      "explanation": "Throughput is defined as the number of processes that complete their execution per time unit[cite: 90]."
    },
    {
      "q": "What is a Bootstrap Program?",
      "options": [
        "A program stored in firmware that initializes the system and loads the kernel."
      ],
      "correct": 0,
      "explanation": "The bootstrap program runs at startup, stored in firmware, and is responsible for determining which operating system to boot into and loading it[cite: 258]."
    },
    {
      "q": "If a system uses a Microkernel structure, where do most services (like file systems) run?",
      "options": [
        "In Kernel Mode",
        "In User Space",
        "In the Hardware",
        "In the BIOS"
      ],
      "correct": 1,
      "explanation": "A microkernel structure moves as much as possible from the kernel into user space[cite: 209]. Note: While text specifically discusses shell/interpreters being separate, the general concept of Microkernels (implied in standard OS curricula) moves services to user space to keep the kernel small."
    },
    {
      "q": "What is the primary difference between Preemptive and Nonpreemptive scheduling?",
      "options": [
        "Preemptive scheduling allows a process to be interrupted in the midst of execution to allocate the CPU to another process, whereas Nonpreemptive scheduling ensures a process keeps the CPU until it finishes or waits."
      ],
      "correct": 0,
      "explanation": "Preemptive scheduling allows interruption of a running process, while nonpreemptive requires the process to voluntarily relinquish control[cite: 276]."
    }
  ]
}