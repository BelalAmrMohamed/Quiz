{
  "meta": {
    "title": "Final السنة اللي فاتت",
    "id": "SAPKL7VW",
    "createdAt": "2026-03-01 - 20:37",
    "path": "quizzes/Computer Science/2/1/Operatings Systems/Final السنة اللي فاتت.json"
  },
  "stats": {
    "questionCount": 60,
    "questionTypes": [
      "MCQ"
    ]
  },
  "questions": [
    {
      "q": "The bootstrap program is stored in:",
      "explanation": "The bootstrap program is stored in ROM/EPROM (firmware) because it needs to be available when the computer starts up, before any other storage is accessible.",
      "options": [
        "Hard disk",
        "RAM",
        "ROM/EPROM",
        "Cache"
      ],
      "correct": 2
    },
    {
      "q": "Which component manages I/O device buffers?",
      "explanation": "Device controllers manage I/O device buffers, handling the temporary storage of data being transferred to and from I/O devices.",
      "options": [
        "CPU",
        "Device controller",
        "Kernel",
        "Cache"
      ],
      "correct": 1
    },
    {
      "q": "Priority scheduling may cause:",
      "explanation": "Priority scheduling can cause starvation, where low-priority processes may never get CPU time if high-priority processes keep arriving.",
      "options": [
        "High throughput",
        "Starvation",
        "Deadlock",
        "Cache misses"
      ],
      "correct": 1
    },
    {
      "q": "The PCB stores:",
      "explanation": "The Process Control Block (PCB) stores process state information including registers, program counter, CPU scheduling information, and memory management information.",
      "options": [
        "Process state and registers",
        "User passwords",
        "Disk sectors",
        "Network IPs"
      ],
      "correct": 0
    },
    {
      "q": "MS-DOS is an example of:",
      "explanation": "MS-DOS is an example of a simple structure OS with minimal structure and no clear separation between interfaces and levels of functionality.",
      "options": [
        "Layered OS",
        "Simple structure OS",
        "Microkernel",
        "Hybrid OS"
      ],
      "correct": 1
    },
    {
      "q": "UNIX separates:",
      "explanation": "UNIX separates the kernel (core OS functionality) from system programs (utilities and applications), providing a layered approach.",
      "options": [
        "None",
        "Hardware and users",
        "CPU and GPU",
        "Kernel and system programs"
      ],
      "correct": 3
    },
    {
      "q": "A microkernel moves most functionality to:",
      "explanation": "A microkernel architecture moves most OS services to user space, keeping only essential functions like IPC and basic scheduling in the kernel.",
      "options": [
        "Kernel space",
        "User space",
        "Hardware",
        "BIOS"
      ],
      "correct": 1
    },
    {
      "q": "The ready queue holds processes:",
      "explanation": "The ready queue contains processes that are ready to execute and waiting for CPU time.",
      "options": [
        "Waiting for I/O",
        "Terminated",
        "Ready to execute",
        "Zombie"
      ],
      "correct": 2
    },
    {
      "q": "A device queue is for processes:",
      "explanation": "A device queue holds processes waiting for I/O operations on a particular device.",
      "options": [
        "Waiting for I/O",
        "Waiting for CPU",
        "Terminated",
        "New"
      ],
      "correct": 0
    },
    {
      "q": "I/O-bound processes have:",
      "explanation": "I/O-bound processes have short CPU bursts because they spend most of their time waiting for I/O operations.",
      "options": [
        "Short CPU bursts",
        "Long CPU bursts",
        "No I/O",
        "High priority"
      ],
      "correct": 0
    },
    {
      "q": "What structure is used in MS-DOS?",
      "explanation": "MS-DOS uses a simple structure with minimal organization and no clear modular design.",
      "options": [
        "Layered",
        "Hybrid",
        "Simple",
        "Microkernel"
      ],
      "correct": 2
    },
    {
      "q": "During a CPU switch, the OS saves process state in:",
      "explanation": "During a context switch, the OS saves the current process state in its Process Control Block (PCB).",
      "options": [
        "PCB",
        "Cache",
        "Disk",
        "BIOS"
      ],
      "correct": 0
    },
    {
      "q": "The first commercial disk drive (IBM RAMDAC) stored:",
      "explanation": "The first commercial disk drive, IBM's RAMAC, stored approximately 5MB of data.",
      "options": [
        "1GB",
        "1TB",
        "5KB",
        "5MB"
      ],
      "correct": 3
    },
    {
      "q": "A process ID is assigned when a process is:",
      "explanation": "A process ID (PID) is assigned when a process is created by the operating system.",
      "options": [
        "Blocked",
        "Ready",
        "Created",
        "Terminated"
      ],
      "correct": 2
    },
    {
      "q": "Which state means the process is waiting for CPU?",
      "explanation": "The ready state means the process is waiting for CPU time to execute.",
      "options": [
        "Running",
        "Ready",
        "Terminated",
        "New"
      ],
      "correct": 1
    },
    {
      "q": "A timer interrupt prevents:",
      "explanation": "Timer interrupts prevent infinite loops by ensuring the OS regains control periodically, allowing for process scheduling and preventing a single process from monopolizing the CPU.",
      "options": [
        "Deadlocks",
        "Power loss",
        "Crashes",
        "Infinite loops"
      ],
      "correct": 3
    },
    {
      "q": "A process is:",
      "explanation": "A process is a program in execution, representing the active instance of a program with its own state and resources.",
      "options": [
        "passive entity",
        "storage device",
        "hardware component",
        "program in execution"
      ],
      "correct": 3
    },
    {
      "q": "Which storage device is logically divided into tracks and sectors?",
      "explanation": "Hard disks are logically divided into tracks (concentric circles) and sectors (segments of tracks) for data organization.",
      "options": [
        "SSD",
        "Hard disk",
        "Cache",
        "RAM"
      ],
      "correct": 1
    },
    {
      "q": "Dual-mode operation separates:",
      "explanation": "Dual-mode operation separates user mode and kernel mode to provide protection and security by restricting user programs from accessing critical system resources.",
      "options": [
        "User and kernel modes",
        "CPU and GPU",
        "RAM and ROM",
        "Input and output"
      ],
      "correct": 0
    },
    {
      "q": "A single-threaded process has:",
      "explanation": "A single-threaded process has one program counter that tracks the execution of a single sequence of instructions.",
      "options": [
        "Multiple program counters",
        "One program counter",
        "No registers",
        "Shared memory"
      ],
      "correct": 1
    },
    {
      "q": "Deadlock prevention avoids:",
      "explanation": "Deadlock prevention can avoid deadlocks by ensuring at least one of the four necessary conditions (mutual exclusion, hold and wait, no preemption, circular wait) cannot occur.",
      "options": [
        "Mutual exclusion",
        "Circular wait",
        "Resource allocation",
        "All of the above"
      ],
      "correct": 3
    },
    {
      "q": "The \"Ostrich Algorithm\" refers to:",
      "explanation": "The Ostrich Algorithm refers to ignoring the deadlock problem, assuming it's rare enough that the cost of handling it exceeds the cost of occasional system restarts.",
      "options": [
        "Ignoring deadlocks",
        "Preventing deadlocks",
        "Detecting deadlocks",
        "Resolving deadlocks"
      ],
      "correct": 0
    },
    {
      "q": "In SJF scheduling, the next process chosen has the:",
      "explanation": "Shortest Job First (SJF) scheduling selects the process with the shortest CPU burst time to minimize average waiting time.",
      "options": [
        "Longest burst time",
        "Shortest burst time",
        "Highest priority",
        "Lowest priority"
      ],
      "correct": 1
    },
    {
      "q": "Round Robin scheduling uses:",
      "explanation": "Round Robin scheduling uses a fixed time quantum (time slice) and rotates through processes in a circular manner.",
      "options": [
        "A fixed time quantum",
        "Dynamic priorities",
        "No time limits",
        "Batch processing"
      ],
      "correct": 0
    },
    {
      "q": "Multilevel queue scheduling combines:",
      "explanation": "Multilevel queue scheduling uses multiple queues, each with its own scheduling algorithm, for different types of processes.",
      "options": [
        "Only FCFS queue",
        "Single FIFO queue",
        "Multiple queues with different algorithms",
        "No queues"
      ],
      "correct": 2
    },
    {
      "q": "The short-term scheduler runs:",
      "explanation": "The short-term (CPU) scheduler runs very frequently, typically every few milliseconds, to select the next process to execute.",
      "options": [
        "Every few seconds",
        "Every few milliseconds",
        "Only at startup",
        "Never"
      ],
      "correct": 1
    },
    {
      "q": "Loadable kernel modules used in:",
      "explanation": "Loadable kernel modules (LKMs) are used in modern operating systems like Linux and Solaris to extend kernel functionality dynamically.",
      "options": [
        "Linux and Solaris",
        "MS-DOS",
        "Early UNIX",
        "Embedded systems"
      ],
      "correct": 0
    },
    {
      "q": "In IPC Message passing is preferred for:",
      "explanation": "Message passing is preferred for distributed systems where processes may be on different machines and cannot share memory.",
      "options": [
        "Large data transfers",
        "Distributed systems",
        "Kernel modules",
        "Hardware drivers"
      ],
      "correct": 1
    },
    {
      "q": "PCB does NOT store which of the following?",
      "explanation": "The PCB does not store user passwords. It stores process-related information like state, registers, memory allocation, and scheduling information.",
      "options": [
        "Memory allocation",
        "Program counter",
        "CPU registers",
        "User password"
      ],
      "correct": 3
    },
    {
      "q": "The long-term scheduler controls:",
      "explanation": "The long-term (job) scheduler controls the degree of multiprogramming by deciding which processes should be brought into memory.",
      "options": [
        "Degree of multiprogramming",
        "CPU interrupts",
        "Disk speed",
        "Cache size"
      ],
      "correct": 0
    },
    {
      "q": "The interrupt vector contains:",
      "explanation": "The interrupt vector contains addresses of interrupt service routines that handle different types of interrupts.",
      "options": [
        "Memory blocks",
        "Process IDs",
        "Addresses of service routines",
        "Disk sectors"
      ],
      "correct": 2
    },
    {
      "q": "Which queue holds all processes in the system?",
      "explanation": "The job queue holds all processes in the system, regardless of their state.",
      "options": [
        "Job queue",
        "Ready queue",
        "Device queue",
        "Execution queue"
      ],
      "correct": 0
    },
    {
      "q": "IPC is needed for:",
      "explanation": "Inter-Process Communication (IPC) is needed for cooperating processes that need to exchange data and coordinate their actions.",
      "options": [
        "Independent processes",
        "User login",
        "Cooperating processes",
        "Memory allocation"
      ],
      "correct": 2
    },
    {
      "q": "Which is NOT an advantage of process cooperation?",
      "explanation": "Security is not inherently an advantage of process cooperation; in fact, IPC can introduce security challenges. Advantages include information sharing, computation speed-up, and convenience.",
      "options": [
        "Information sharing",
        "Speed-up",
        "Convenience",
        "Security"
      ],
      "correct": 3
    },
    {
      "q": "Zombie process means:",
      "explanation": "A zombie process is one that has finished execution but still has an entry in the process table because its parent hasn't read its exit status yet.",
      "options": [
        "Terminated and cleaned",
        "Active and running",
        "Finished but not cleaned",
        "Waiting in I/O"
      ],
      "correct": 2
    },
    {
      "q": "Mode bit distinguishes between:",
      "explanation": "The mode bit distinguishes between kernel mode (privileged) and user mode (restricted) execution.",
      "options": [
        "Processes",
        "Kernel and user mode",
        "Primary and secondary memory",
        "Threads"
      ],
      "correct": 1
    },
    {
      "q": "Round Robin ensures:",
      "explanation": "Round Robin ensures fair CPU time sharing by giving each process an equal time quantum in a circular fashion.",
      "options": [
        "Equal memory for all",
        "Non-preemption",
        "Fair CPU time share",
        "Priority handling"
      ],
      "correct": 2
    },
    {
      "q": "Which is true for FCFS scheduling?",
      "explanation": "First-Come, First-Served (FCFS) scheduling processes requests in the order they arrive (arrival order).",
      "options": [
        "Shortest job first",
        "Preemptive",
        "Processes run in arrival order",
        "Round-robin"
      ],
      "correct": 2
    },
    {
      "q": "Turnaround Time = Completion Time - ...",
      "explanation": "Turnaround Time = Completion Time - Arrival Time. It represents the total time from when a process arrives until it completes.",
      "options": [
        "Burst Time",
        "Waiting Time",
        "Start Time",
        "Arrival Time"
      ],
      "correct": 3
    },
    {
      "q": "Waiting Time = Turnaround Time - ...",
      "explanation": "Waiting Time = Turnaround Time - Burst Time. It represents the time a process spends waiting in the ready queue.",
      "options": [
        "Completion Time",
        "Burst Time",
        "Arrival Time",
        "Priority"
      ],
      "correct": 1
    },
    {
      "q": "In RR, when time quantum ends, Process:",
      "explanation": "In Round Robin, when a process's time quantum expires, it is moved to the back of the ready queue.",
      "options": [
        "Terminated",
        "Priority changes",
        "Moved to back of queue",
        "Restarted"
      ],
      "correct": 2
    },
    {
      "q": "What algorithm schedules smallest job next?",
      "explanation": "Shortest Job First (SJF) algorithm schedules the smallest (shortest burst time) job next.",
      "options": [
        "FCFS",
        "RR",
        "Priority",
        "SJF"
      ],
      "correct": 3
    },
    {
      "q": "What is an operating system?",
      "explanation": "An operating system is a program that manages computer hardware and provides services for application programs.",
      "options": [
        "A program managing hardware",
        "A peripheral device",
        "A compiler",
        "A user interface"
      ],
      "correct": 0
    },
    {
      "q": "Which is NOT a component of a computer system?",
      "explanation": "BIOS Settings are configuration options, not a fundamental component of a computer system. The main components are hardware, operating system, application programs, and users.",
      "options": [
        "Users",
        "Applications/Programs",
        "Hardware",
        "BIOS Settings"
      ],
      "correct": 3
    },
    {
      "q": "What is the bootstrap program responsible for?",
      "explanation": "The bootstrap program (bootloader) is responsible for loading the operating system kernel into memory during system startup.",
      "options": [
        "OS kernel loading",
        "Printing",
        "Shutting down",
        "Game loading"
      ],
      "correct": 0
    },
    {
      "q": "Which is the fastest and most expensive storage in the hierarchy?",
      "explanation": "Cache memory is the fastest and most expensive storage in the memory hierarchy, located between CPU and RAM.",
      "options": [
        "Hard Disk",
        "Cache",
        "RAM",
        "SSD"
      ],
      "correct": 1
    },
    {
      "q": "What happens in SJF scheduling?",
      "explanation": "In Shortest Job First (SJF) scheduling, the process with the smallest CPU burst time is scheduled first.",
      "options": [
        "Priority-based only",
        "Round robin rotation",
        "Longest job goes first",
        "Smallest burst job first"
      ],
      "correct": 3
    },
    {
      "q": "A head crash occurs when:",
      "explanation": "A head crash occurs when the read/write head of a hard disk physically touches the disk surface, causing damage.",
      "options": [
        "The disk head touches the surface",
        "The CPU overheats",
        "Memory is full",
        "The OS crashes"
      ],
      "correct": 0
    },
    {
      "q": "Which of the following is NOT a goal of an operating system?",
      "explanation": "Maximizing hardware cost is not a goal. OS goals include executing user programs, making the computer convenient to use, and using hardware efficiently.",
      "options": [
        "Execute user programs",
        "Maximize hardware cost",
        "Efficient hardware use",
        "Convenience"
      ],
      "correct": 1
    },
    {
      "q": "What is the \"kernel\"?",
      "explanation": "The kernel is the core program of the operating system that is always running and manages system resources.",
      "options": [
        "A type of hardware",
        "A user application",
        "The core program always running on the computer",
        "A memory module"
      ],
      "correct": 2
    },
    {
      "q": "The von Neumann bottleneck refers to:",
      "explanation": "The von Neumann bottleneck refers to the limitation caused by the shared bus between CPU and memory, which can slow down data transfer.",
      "options": [
        "CPU overheating",
        "Slow CPU-memory data transfer",
        "Disk fragmentation",
        "Network latency"
      ],
      "correct": 1
    },
    {
      "q": "A multicore processor has:",
      "explanation": "A multicore processor has multiple processing cores integrated on a single chip.",
      "options": [
        "Multiple CPUs on separate chips",
        "No cache",
        "Only one thread",
        "Multiple cores on one chip"
      ],
      "correct": 3
    },
    {
      "q": "Multiprogramming aims to:",
      "explanation": "Multiprogramming aims to keep the CPU busy at all times by having multiple processes in memory and switching between them.",
      "options": [
        "Keep the CPU idle",
        "Keep the CPU busy",
        "Reduce memory usage",
        "Increase user interaction"
      ],
      "correct": 1
    },
    {
      "q": "Deadlock occurs when:",
      "explanation": "Deadlock occurs when processes wait indefinitely for resources held by other waiting processes, creating a circular wait condition.",
      "options": [
        "Processes crash",
        "Processes wait indefinitely for resources",
        "CPU is overloaded",
        "Memory is full"
      ],
      "correct": 1
    },
    {
      "q": "A zombie process is:",
      "explanation": "A zombie process is a terminated process whose exit status has not yet been read by its parent process.",
      "options": [
        "A terminated process with an unread exit status",
        "An orphaned process",
        "A running process",
        "A system daemon"
      ],
      "correct": 0
    },
    {
      "q": "A process state diagram includes:",
      "explanation": "The process state diagram includes states: New, Ready, Running, Waiting (Blocked), and Terminated.",
      "options": [
        "Input, Output, Compute",
        "Start, Stop, Pause",
        "New, Ready, Running, Waiting, Terminate",
        "Read, Write, Execute"
      ],
      "correct": 2
    },
    {
      "q": "IPC stands for:",
      "explanation": "IPC stands for Inter-Process Communication, the mechanism for processes to communicate and synchronize their actions.",
      "options": [
        "Inter Process Communication",
        "Internal Processor Cache",
        "Internet Protocol Control",
        "Input Process Control"
      ],
      "correct": 0
    },
    {
      "q": "In IPC Shared memory is:",
      "explanation": "Shared memory is generally faster than message passing because it avoids system calls after the shared memory region is established.",
      "options": [
        "Slower than message passing",
        "Faster than message passing",
        "Unusable in modern OS",
        "Only for networking"
      ],
      "correct": 1
    },
    {
      "q": "What is the primary role of an operating system?",
      "explanation": "The operating system serves all these roles: managing hardware resources, acting as an intermediary between users and hardware, and providing an environment for program execution.",
      "options": [
        "To manage hardware resources",
        "To act as an intermediary between users and hardware",
        "To execute user programs",
        "All of the above"
      ],
      "correct": 3
    },
    {
      "q": "The four components of a computer system are:",
      "explanation": "The four main components of a computer system are Hardware, Operating System, Application Programs, and Users.",
      "options": [
        "Hardware, OS, Apps, Users",
        "CPU, RAM, OS, Apps",
        "Kernel, Drivers, BIOS, Users",
        "Input, Output, Storage, OS"
      ],
      "correct": 0
    }
  ]
}