/* 
The next line runs this file which generates Script/examManifest.js
node tools/generateExamManifest.js
*/

const fs = require("fs").promises;
const path = require("path");

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map((entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? walk(res) : res;
    })
  );
  return Array.prototype.concat(...files);
}

function titleCase(name) {
  return name.replace(/[-_]/g, " ").replace(/\b\w/g, (m) => m.toUpperCase());
}

async function buildCategoryTree(examsDir) {
  const tree = {};
  const usedIds = new Set();

  function generateUniqueId(baseId, categoryPath) {
    let id = baseId;
    let counter = 1;

    // First try: use the base ID
    if (!usedIds.has(id)) {
      usedIds.add(id);
      return id;
    }

    // Second try: append category name
    const categoryName = categoryPath[categoryPath.length - 1] || "";
    if (categoryName) {
      id = `${categoryName}-${baseId}`;
      if (!usedIds.has(id)) {
        usedIds.add(id);
        return id;
      }
    }

    // Third try: append full path
    if (categoryPath.length > 0) {
      id = `${categoryPath.join("-")}-${baseId}`;
      if (!usedIds.has(id)) {
        usedIds.add(id);
        return id;
      }
    }

    // Last resort: append counter
    id = baseId;
    while (usedIds.has(`${id}-${counter}`)) {
      counter++;
    }
    id = `${id}-${counter}`;
    usedIds.add(id);
    return id;
  }

  async function scanDir(dir, parentPath = []) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const currentPath = [...parentPath, entry.name];

      if (entry.isDirectory()) {
        const categoryKey = currentPath.join("/");
        if (!tree[categoryKey]) {
          tree[categoryKey] = {
            name: entry.name,
            path: currentPath,
            parent: parentPath.join("/") || null,
            subcategories: [],
            exams: [],
          };
        }

        // Add to parent's subcategories
        if (parentPath.length > 0) {
          const parentKey = parentPath.join("/");
          if (!tree[parentKey]) {
            tree[parentKey] = {
              name: parentPath[parentPath.length - 1],
              path: parentPath,
              parent: parentPath.slice(0, -1).join("/") || null,
              subcategories: [],
              exams: [],
            };
          }
          if (!tree[parentKey].subcategories.includes(categoryKey)) {
            tree[parentKey].subcategories.push(categoryKey);
          }
        }

        await scanDir(fullPath, currentPath);
      } else if (entry.name.endsWith(".js")) {
        const categoryKey = parentPath.join("/");
        const fileName = entry.name;
        const baseId = fileName.replace(/\.js$/, "");

        // Generate unique ID
        const id = generateUniqueId(baseId, parentPath);
        const title = titleCase(baseId);

        const scriptDir = path.join(path.dirname(examsDir), "Script");
        let relPath = path
          .relative(scriptDir, fullPath)
          .split(path.sep)
          .join("/");
        if (!relPath.startsWith(".")) relPath = "./" + relPath;

        const exam = {
          id,
          title,
          path: relPath,
          category: categoryKey,
        };

        if (tree[categoryKey]) {
          tree[categoryKey].exams.push(exam);
        }
      }
    }
  }

  await scanDir(examsDir);
  return tree;
}

async function generate() {
  const repoRoot = path.resolve(__dirname, "..");
  const examsDir = path.join(repoRoot, "Exams");
  const scriptDir = path.join(repoRoot, "Script");

  const categoryTree = await buildCategoryTree(examsDir);

  // Flatten exams for backward compatibility
  const allExams = [];
  Object.values(categoryTree).forEach((cat) => {
    cat.exams.forEach((exam) => allExams.push(exam));
  });

  allExams.sort((a, b) => (a.category + a.id).localeCompare(b.category + b.id));

  // Verify no duplicate IDs
  const idCounts = {};
  allExams.forEach((exam) => {
    idCounts[exam.id] = (idCounts[exam.id] || 0) + 1;
  });
  const duplicates = Object.entries(idCounts).filter(([_, count]) => count > 1);
  if (duplicates.length > 0) {
    console.error("ERROR: Duplicate IDs found:");
    duplicates.forEach(([id, count]) => {
      console.error(`  - "${id}" appears ${count} times`);
    });
    process.exit(1);
  }

  const outFile = path.join(scriptDir, "examManifest.js");
  const header = `// Auto-generated by tools/generateExamManifest.js - do not edit by hand\n// Run: node tools/generateExamManifest.js\n\n`;
  const body =
    "export const examList = " +
    JSON.stringify(allExams, null, 2) +
    ";\n\n" +
    "export const categoryTree = " +
    JSON.stringify(categoryTree, null, 2) +
    ";\n";

  await fs.writeFile(outFile, header + body, "utf8");
  console.log("Wrote", outFile);
  console.log(
    `Generated ${allExams.length} exams across ${
      Object.keys(categoryTree).length
    } categories`
  );
}

generate().catch((err) => {
  console.error(err);
  process.exit(1);
});
