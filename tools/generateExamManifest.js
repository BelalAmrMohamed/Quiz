#!/usr/bin/env node

/* 
The next line runs this file which generates Script/examManifest.js
node tools/generateExamManifest.js; 

git add Script/examManifest.js; 
git commit -m "chore: regenerate examManifest.js"
*/
const fs = require("fs").promises;
const path = require("path");

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map((entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? walk(res) : res;
    })
  );
  return Array.prototype.concat(...files);
}

function titleCase(name) {
  return name.replace(/[-_]/g, " ").replace(/\b\w/g, (m) => m.toUpperCase());
}

async function buildCategoryTree(examsDir) {
  const tree = {};

  async function scanDir(dir, parentPath = []) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const currentPath = [...parentPath, entry.name];

      if (entry.isDirectory()) {
        const categoryKey = currentPath.join("/");
        if (!tree[categoryKey]) {
          tree[categoryKey] = {
            name: entry.name,
            path: currentPath,
            parent: parentPath.join("/") || null,
            subcategories: [],
            exams: [],
          };
        }

        // Add to parent's subcategories
        if (parentPath.length > 0) {
          const parentKey = parentPath.join("/");
          if (!tree[parentKey]) {
            tree[parentKey] = {
              name: parentPath[parentPath.length - 1],
              path: parentPath,
              parent: parentPath.slice(0, -1).join("/") || null,
              subcategories: [],
              exams: [],
            };
          }
          if (!tree[parentKey].subcategories.includes(categoryKey)) {
            tree[parentKey].subcategories.push(categoryKey);
          }
        }

        await scanDir(fullPath, currentPath);
      } else if (entry.name.endsWith(".js")) {
        const categoryKey = parentPath.join("/");
        const fileName = entry.name;
        const id = fileName.replace(/\.js$/, "");
        const title = titleCase(id);

        const scriptDir = path.join(path.dirname(examsDir), "Script");
        let relPath = path
          .relative(scriptDir, fullPath)
          .split(path.sep)
          .join("/");
        if (!relPath.startsWith(".")) relPath = "./" + relPath;

        const exam = {
          id,
          title,
          path: relPath,
          category: categoryKey,
        };

        if (tree[categoryKey]) {
          tree[categoryKey].exams.push(exam);
        }
      }
    }
  }

  await scanDir(examsDir);
  return tree;
}

async function generate() {
  const repoRoot = path.resolve(__dirname, "..");
  const examsDir = path.join(repoRoot, "Exams");
  const scriptDir = path.join(repoRoot, "Script");

  const categoryTree = await buildCategoryTree(examsDir);

  // Flatten exams for backward compatibility
  const allExams = [];
  Object.values(categoryTree).forEach((cat) => {
    cat.exams.forEach((exam) => allExams.push(exam));
  });

  allExams.sort((a, b) => (a.category + a.id).localeCompare(b.category + b.id));

  const outFile = path.join(scriptDir, "examManifest.js");
  const header = `// Auto-generated by tools/generateExamManifest.js - do not edit by hand\n// Run: node tools/generateExamManifest.js\n\n`;
  const body =
    "export const examList = " +
    JSON.stringify(allExams, null, 2) +
    ";\n\n" +
    "export const categoryTree = " +
    JSON.stringify(categoryTree, null, 2) +
    ";\n";

  await fs.writeFile(outFile, header + body, "utf8");
  console.log("Wrote", outFile);
  console.log(
    `Generated ${allExams.length} exams across ${
      Object.keys(categoryTree).length
    } categories`
  );
}

generate().catch((err) => {
  console.error(err);
  process.exit(1);
});
